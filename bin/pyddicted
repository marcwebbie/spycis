#!/usr/bin/env python
# -*- coding: utf-8 -*-
import argparse
from collections import namedtuple
from difflib import SequenceMatcher
import os
import sys

import guessit
import requests
from pyquery import PyQuery

headers = {
    "User-Agent": ("Mozilla/5.0 (X11; Linux x86_64) "
                   "AppleWebKit/537.36 (KHTML, like Gecko) "
                   "Chrome/32.0.1674.0 Safari/537.36")
}
session = requests.Session()
session.headers.update(headers)
http_adapter = requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100)
session.mount('http://', http_adapter)


# class lazyproperty:

#     def __init__(self, func):
#         self.func = func

#     def __get__(self, instance, cls):
#         if instance is None:
#             return self
#         else:
#             value = self.func(instance)
#             setattr(instance, self.func.__name__, value)
#             return value


def lazyproperty(func):
    name = '_lazy_' + func.__name__

    @property
    def lazy(self):
        if hasattr(self, name):
            return getattr(self, name)
        else:
            value = func(self)
            setattr(self, name, value)
            return value
    return lazy


class Subtitle(object):

    def __init__(self):
        self.show = None
        self.season = None
        self.episode = None
        self.episode_title = None
        self.language = None
        self.version = None
        self.completed = None
        self.hearing_impaired = None
        self.corrected = None
        self.hd = None
        self.url = None
        self.retrieved_from_url = None

    def __str__(self):
        return "<Subtitle: {0.show}, s{0.season}e{0.episode}, {0.episode_title}, {0.version}, {0.language}>".format(self)

    def __repr__(self):
        return self.__str__()


class Addicted(object):

    def get_language_code(self, name):
        langs = {'Arabic': 'ar',
                 'Catala': 'ca',
                 'English': 'en',
                 'Euskera': 'eu',
                 'French': 'fr',
                 'Germnan': 'de',
                 'Italian': 'it',
                 'Portuguese (Brazilian)': 'br',
                 'Spanish': 'es'}
        return langs.get(name, None)

    @lazyproperty
    def shows(self):
        Show = namedtuple("Show", ["id", "name"])
        res = session.get('http://www.addic7ed.com/shows.php')
        return [Show(a.attr('href').split('/')[-1], a.text()) for a in PyQuery(res.content)('td.version a').items()]

    def get_subtitle_text(self, subtitle):
        r = session.get(subtitle.url, headers={'Referer': subtitle.retrieved_from_url})
        return r.text

    def get_subtitles(self, show_id, season, episode, language='en', hearing_impaired=False, release_group=None):
        site_url = "http://www.addic7ed.com"
        apiurl = "http://www.addic7ed.com/show/{0}&season={1}".format(show_id, season)
        pq = PyQuery(apiurl)
        try:
            show_name = pq('#header>a').attr('href').split('/')[-1].replace('_', ' ')
        except:
            show_name = "Unknown"

        subtitles = []
        for cells in [tr.getchildren() for tr in pq('tr.completed')]:
            sub = Subtitle()
            sub.show = show_name
            sub.season = int(cells[0].text)
            sub.episode = int(cells[1].text)
            sub.episode_title = pq('a', cells[2]).text()
            sub.language = self.get_language_code(cells[3].text)
            sub.version = cells[4].text
            sub.completed = True if cells[5].text else False
            sub.hearing_impaired = True if cells[6].text else False
            sub.corrected = True if cells[7].text else False
            sub.hd = True if cells[8].text else False
            sub.url = site_url + pq('a', cells[9]).attr('href')
            sub.retrieved_from_url = apiurl

            # print(sub)
            subtitles.append(sub)

        # filter subs
        subtitles = [
            sub for sub in subtitles
            if (
                sub.season == season and
                sub.episode == episode and
                sub.language == language and
                sub.hearing_impaired == hearing_impaired
            )
        ]

        if isinstance(release_group, str) and any(True for s in subtitles if release_group in s.version):
            return [s for s in subtitles if release_group in s.version]
        else:
            return subtitles

    def search(self, query):
        search_result = {show: SequenceMatcher(None, query.lower(), show.name.lower()).quick_ratio() for show in self.shows}
        full_matches = [show for show, ratio in search_result.items() if ratio == 1.0]
        if full_matches:
            return full_matches
        else:
            return sorted(search_result, key=d.get, reverse=True)[:10]


def get_args():
    aparser = argparse.ArgumentParser()
    aparser.add_argument("-l", "--language", default='en', help="subtitles language")
    aparser.add_argument("-o", "--output", help="output filepath")
    aparser.add_argument("--stdout", action='store_true', help="print to stdout")
    aparser.add_argument("filepath", help="path to file for subtitles")
    args = aparser.parse_args()

    return args


if __name__ == "__main__":
    args = get_args()
    filepath = args.filepath
    info = guessit.guess_video_info(filepath)

    a = Addicted()
    search_result = a.search(info['series'])
    if len(search_result) == 1:
        show = search_result[0]
        season = info['season']
        episode = info['episodeNumber']
        release = info.get('releaseGroup', None)
        language = args.language
        subs = a.get_subtitles(show_id=show.id, season=season, episode=episode, language=language, release_group=release)

        for s in subs:
            sys.stderr.write("{}\n".format(s))

        if len(subs) > 0:
            first_sub = subs[0]
            subtitles_text = a.get_subtitle_text(first_sub)
            if args.stdout:
                print(subtitles_text)
            else:
                filename = args.output if args.output else os.path.splitext(filepath)[0] + '.srt'
                with open(filename, 'w') as subfile:
                    subfile.write(subtitles_text)
                sys.stderr.write("Subtitles save as: {}\n".format(filename))
    else:
        sys.stderr.write('Not unique search')
        sys.stderr.write("{}\n".format(info))
        for show in search_result:
            sys.stderr.write("{}\n".format(show))
