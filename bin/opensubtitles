#!/usr/bin/env python
# -*- coding: utf-8 -*-
import argparse
from collections import namedtuple
from difflib import SequenceMatcher
import os
import sys
import re
import zipfile
try:
    from io import BytesIO
except:
    # python2
    from StringIO import StringIO as BytesIO

import guessit
import requests
from pyquery import PyQuery

__version__ = "0.0.1-dev1"

headers = {
    "User-Agent": ("Mozilla/5.0 (X11; Linux x86_64) "
                   "AppleWebKit/537.36 (KHTML, like Gecko) "
                   "Chrome/32.0.1674.0 Safari/537.36")
}
session = requests.Session()
session.headers.update(headers)
http_adapter = requests.adapters.HTTPAdapter(
    pool_connections=100, pool_maxsize=100)
session.mount('http://', http_adapter)


def get_zip_content(sub_id):
    download_url = "http://dl.opensubtitles.org/fr/download/sub/{}"
    zip_response = session.get(download_url.format(sub_id))
    zfile = zipfile.ZipFile(BytesIO(zip_response.content))

    FORMATS = (".sub", ".srt", ".idx", ".ass")
    for sub_name in (name for name in zfile.namelist()
                     if os.path.splitext(name)[-1] in FORMATS):
        return zfile.read(sub_name)
    else:
        return None

Subtitle = namedtuple("Subtitle", "id title format")


def get_subtitles(video_path, language, *args, **kwargs):
    """
    Go to opensubtitles and download w
    """

    video_path = os.path.basename(os.path.abspath(video_path))
    guessit.patterns.basestring = str  # Patch ugly code
    info = guessit.guess_episode_info(video_path)

    try:
        show = info['series']
        season = info['season']
        episode = info['episodeNumber']
    except KeyError:
        print("Couldn't guess video info from file: {}".format(video_path))
        sys.exit(1)

    api_url = "http://www.opensubtitles.org/fr/search2"

    params = {
        "MovieName": show,
        "id": 8,
        "action": "search",
        "SubLanguageID": language,
        "SubLanguageID": language,
        "SearchOnlyTVSeries": "on",
        "Season": season,
        "Episode": episode,
        "SubSumCD": 1,
        "Genre": "",
        "MovieByteSize": "",
        "MovieLanguage": "",
        "MovieImdbRatingSign": 1,
        "MovieImdbRating": "",
        "MovieCountry": "",
        "MovieYearSign": 1,
        "MovieYear": kwargs.get('year', ""),
        "MovieFPS": "",
        "SubFormat": "",
        "SubAddDate": "",
        "Uploader": "",
        "IDUser": "",
        "IMDBID": kwargs.get('imdbid', ""),
        "IDMovie": "",
        "MovieHash": kwargs.get('movie_hash', ""),
    }

    res = session.get(api_url, params=params)
    pq = PyQuery(res.content)

    subtitles = []
    for elem in pq('table#search_results tr[id^="name"]').items():
        sub_id = elem.attr('id').replace('name', '')
        sub_format = elem('.p:last').text()
        elem('td:first a').remove()
        elem('td:first img').remove()
        elem('td:first strong').remove()
        sub_title = re.sub(r'\[.*?\]\s+', '', elem('td:first').text())

        sub = Subtitle(id=sub_id, title=sub_title, format=sub_format)
        subtitles.append(sub)

    return subtitles


def get_args():
    aparser = argparse.ArgumentParser()
    aparser.add_argument("-l", "--language", default='fre', help="subtitles language")
    aparser.add_argument("-o", "--output", action="store_true", help="output filepath")
    aparser.add_argument("--version", action="version", version=__version__, help="output filepath")
    aparser.add_argument("-i", "--iteractive", action="store_true", help="iteractive mode")
    aparser.add_argument("video_path", help="path to video for seeking subtitles")
    args = aparser.parse_args()

    return args


if __name__ == "__main__":
    args = get_args()
    video_path = args.video_path
    language = args.language
    subtitles = get_subtitles(args.video_path, args.language)
    # print(subtitles)

    if args.iteractive:
        for idx, subtitle in enumerate(subtitles):
            print("[{}] {}".format(idx, subtitle.title))

        sub_choisi = subtitles[int(input("Sous-titres à télécharger : "))]
    else:
        matcher = lambda x: SequenceMatcher(
            lambda s: None, x.title, args.video_path).ratio()
        subs = sorted(subtitles, key=matcher, reverse=True)
        sub_choisi = next((s for s in subs), None)

    if sub_choisi:
        if args.output:
            print(get_zip_content(sub_choisi.id).decode('utf-8', 'ignore'))
        else:
            basename = os.path.splitext(os.path.basename(video_path))[0]
            subfilename = "{}.{}".format(basename, sub_choisi.format)
            with open(subfilename, 'wb') as subfile:
                subfile.write(get_zip_content(sub_choisi.id))
            print("Saved {!r} to: {!r}".format(sub_choisi, subfilename))
    else:
        print("No subtitles were found")
